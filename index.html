<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CANVAS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">
		<link rel="stylesheet" href="css/mycss.css">


		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h1>&lt;CANVAS&gt</h1>
						<aside class="notes">
							Hello, my name is Marina & 
							I would like to tell you about canvas. 
						</aside>
					</section>
					<section>
						<img src="src/1.png" alt="">
						<aside class="notes">
								Canvas is a HTML element is used to draw graphics on a web page. 
								It is a bitmap with an "immediate mode" graphics 
								application programming interface (API) for drawing on it. 
						</aside>
					</section>
					<section>
						<h2 style="color: red">&lt;CANVAS&gt can be used for:</h2>
						<ol>
							<li>Dynamic graphics</li>
							<li>Online and offline games</li>
							<li>Animations</li>
							<li>Interactive video and audio</li>
						</ol>
						<aside class="notes">
							Canvas can be used for:
							•	Dynamic graphics
							•	Online and offline games
							•	Animations
							•	Interactive video and audio
						</aside>
					</section>
					<section>
						<pre><code data-trim data-noescape>
							&lt;canvas id="example" width="150" height="150"&gt 
							&lt;/canvas&gt
						</code></pre>
						<aside class="notes">
							The canvas element is only a container for graphics. 
							In order to draw the graphics, you are supposed to use a script. 
							The canvas element has only two optional attributes, width and height. 
							The default values for heights are 300 px and 150 for width.
							Canvas has several strategies [СТРЭТЕДЖИС] when it comes to drawing paths, boxes, circles, text & additional images. 
						</aside>
					</section>
					<section style="min-width: 100%; padding: 0; margin: 0;">
					<pre><code data-trim data-noescape>
					function draw() {
					   const canvas = document.getElementById('canvas');
					   if (canvas.getContext) {
						let ctx = canvas.getContext('2d');
						ctx.beginPath();
						ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
						ctx.moveTo(110, 75); // Moves the pen 
						ctx.arc(75, 75, 35, 0, Math.PI, false);  // Mouth (clockwise)
						ctx.moveTo(65, 65); // Moves the pen
						ctx.arc(60, 65, 5, 0, Math.PI * 2, true);  // Left eye
						ctx.moveTo(95, 65); // Moves the pen
						ctx.arc(90, 65, 5, 0, Math.PI * 2, true);  // Right eye
						ctx.stroke();
					   }
					}
					</code></pre>
						<img src="src/2.jpg">
						<aside class="notes">
							On the slide you see the function, 
							and next is the result of its work.
							A bit of code:
							1. Function getContext('2d') needed to set context.
							2. Function beginPath() creates a new path.
							5. Function stroke() draws the shape by stroking its outline. 
							3. Function arc draws an arc. The first two parameters of the function -- the coordinates of the circles center, the second is the length of its radius, starting at startAngle (the fourth) and ending at endAngle (the fifth).
							4. Function moveTo() moves the pen to the point with defined coordinates.
						</aside>
					</section>
					<section>
							<h2 style="color: red">And a little about the vaunted animation</h2>	
							<img src="src/html5-canvas-y-u-hate-me-so-much.jpg" alt="" width="450">
					</section>
					<section style="min-width: 100%; height: 100%; padding: 0; margin: 0;">
						<pre><code data-trim data-noescape id="mycode">
	function draw() {
	  const canvas = document.querySelector('canvas');
	  canvas.width = window.innerWidth;
	  canvas.height = window.innerHeight;
	  const c = canvas.getContext('2d');
	  const circlesCount = 800;
	  const maxRadius = 40;
	  const circleArray = [];
	  const colorArray = [ '#046975','#2EA1D4','#3BCC2A' ];
	
	  const debounce = (func) => {...}
	
	  const init = () => {...}
	
	  window.addEventListener('resize', debounce(() => {...})); 
	
	  const Circle = function(x, y, dx, dy, radius) {...}; 
	
	  const animate = () => {...};
	
	  init();
	  animate();
	}
						</code></pre>
						<a href="https://github.com/marry705/canvase_animation" target="_blank">THE CODE</a>
						<aside class="notes">
							The whole question can be considered by clicking on the link, 
							but now we’ve stopped only on the function responsible for the animation.
						</aside>
					</section>
					<section>
						<pre><code data-trim data-noescape>
							const animate = () => {
							  requestAnimationFrame(animate);  
							  c.clearRect(0, 0, innerWidth, innerHeight); // clear shapes
							  for (let i = 0; i < circleArray.length; i++) {
								circleArray[i].update();
							  }
							}
						</code></pre>
						<a href="https://marry705.github.io/canvase_animation/" target="_blank">RESULT</a> 
						<aside class="notes">
							Elements are animated using a loop.  
							Every circle has its own «life» and moves. 
							When the border is reached it bounces [БОНСЕС] back, we slightly [СлАЙТЛИ] moving the image at every frame rendering iteration. 
							1.	Method requestAnimationFrame(callback) requests that the browser call a specified function to update an animation before the next repaint. 
							2.	clearRect() clears any shapes that have been drawn previously.
							3.	Update() – the circle class method, which draws a new circle. 	
						</aside>
					</section>
					<section>
						<h2 style="color: red">Basic animation steps</h2>
						<ol>
							<li>Clear the canvas</li>
							<li>Save the canvas state</li>
							<li>Draw animated shapes</li>
							<li>Restore the canvas state</li>
						</ol>
						<aside class="notes">
							These are the steps you need to take to draw a frame:
							1.	Clear the canvas								
							2.	Save the canvas state
							3.	Draw animated shapes
							4.	Restore the canvas stat.		 
						</aside>
					</section>
					<section>
						<h2 style="color: red">Browser Support for Canvas:</h2>
						<img src="src/3.jpg">
					</section>
				</section>
				<section>
					<section>
						<h1>When and why?</h1>
						<aside class="notes">
							Where and when it will be beneficial for the developer to apply canvas. 		 
						</aside>	
					</section>
					<section>
						<img src="src/4.jpg" alt="">
						<aside class="notes">
							It’s impotent to distinguish between something called immediate 
							mode and retained mode. 
							The Canvas API is an example of immediate mode: you, as the developer, need to work out the commands to draw objects. 
							The browser’s Graphics API simply communicates your drawing commands to the browser, 
							which then executes [ЭКЗЕКЬЮТ] them. It’s mean that canvas hasn’t got a Document Object Model. 
						</aside>
					</section>
					<section>
						<img src="src/14-1.jpg" alt="">
						<aside class="notes">
							With canvas, you draw your pixels and the system forgets all about them, 
							thereby [СЕРЕБАЙ] cutting down on the extra memory needed to maintain an internal model 
							of your drawing.
							Everything is exactly the opposite with SVG, where each drawn object is added to its 
							internal model, which somewhat eases your developer life, but with some cost in terms of performance.
						</aside>
					</section>
					<section>
						<h2 style="color: red">What HTML5 Canvas Can Be Great For</h2>
						<aside class="notes"> 
							Canvas is a resolution-dependent immediate drawing system 
							that doesn’t maintain its own model. The last feature is key to this technology’s drawing capabilities 
							being lightning-fast, which makes Canvas great at performing the following tasks:
						</aside>
					</section>
					<section>
						<h3>Ray Tracing</h3>
						<p>Ray tracing is a technique for creating 3D graphics.
							<br>
							Here’s a <a href="http://jupiter909.com/mark/jsrt-anim.html" target="_blank">raytracer application in action</a>.
						</p> 
						<aside class="notes">
							Ray tracing is a technique [ТЕКНИК] for creating 3D graphics.  
						</aside>
					</section>
					<section>
						<h3>Drawing a significant number of objects on a small surface</h3>
						<img src="src/5.jpg" alt="" width="450">
						<aside class="notes">
							Drawing a significant number of objects on a small surface  
						</aside>
					</section>
					<section>
						<h3>Pixel replacement in videos</h3>
						<img src="src/6.png" alt="" width="450">
						<aside class="notes">
							Pixel replacement [РЕПЛЕЙСМЕНТ] in videos  
						</aside>
					</section>
					<section>
						<h2 style="color: red">What HTML5 Canvas Is Not So Great For</h2>
						<aside class="notes">
							On the other hand, 
							there are a number of cases where canvas is not the best choice.
						</aside>
					</section>
					<section>
						<h3>Scalability</h3>
						<aside class="notes">
							Most scenarios [СИНЕРИАС] where scalability [СКЭЛЭБИЛИТИ] is a plus are going to be better served using SVGs than canvas.
						</aside>
					</section>
					<section>
						<h3>Accessibility</h3>
						<aside class="notes">
							If accessibility [ЭКСЕССЭБИЛИТИ] is impotent to your application, 
							using canvas is generally not recommended. 
							What you draw on the canvas surface is just a bunch of pixels, 
							which can’t be read or interpreted by assistive technologies or search bots.
						</aside>
					</section>
					<section>
						<h3>No reliance on JavaScript</h3>
						<aside class="notes">
							If you don’t want to use JavaScript in your application, 
							then canvas is not your best friend, 
							because the only way you can work with the canvas element is with JavaScript.
						</aside>
					</section>
					<section>
						<h2 style="color: red">Advantages:</h2>
						<ol>
							<li>Canvas is really interactive</li>
							<li>With Canvas, you always have the option of saving images as .png or .jpg</li>
							<li>Any object that you draw on the canvas can be animated</li>
							<li>Very efficient in dealing with multiple elements</li>
						</ol>
						<aside class="notes">
							Advantages:
							1. Canvas is really interactive: 
							2. With Canvas, you always have the option of saving images as .png or .jpg
							3. Any object that you draw on the canvas can be animated
							4. Very efficient [ЭФИШЕНТ] in dealing with multiple elements
						</aside>
					</section>
					<section>
						<h2 style="color: red">Disadvantages:</h2>
						<ol>
							<li>Canvas is dependent on resolution</li>
							<li>Complex visualizations</li>
							<li>It has Poor text rendering capabilities</li>
							<li>It can be slow when drawing to large areas</li>
						</ol>
						<aside class="notes">
						Disadvantages:
							1.	Canvas is dependent on resolution;
							2.	Complex visualizations;
							3.	It has Poor text rendering capabilities;
							4.	It can be slow when drawing to large areas.	
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Instead of a thousand words</h2>
						<ol>
							<li><a href="http://1000.chromeexperiments.com/" target="_blank">BUBBLES</a></li>
							<li><a href="http://www.giantstepsmedias.com/" target="_blank">STARS</a></li>
						</ol>
						<aside class="notes">
							Follow the links provided.	
						</aside>
					</section>
					<section>
						<img src="src/thnk.jpg" alt="">
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
