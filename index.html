<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CANVAS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">
		<link rel="stylesheet" href="css/mycss.css">


		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h1>&lt;CANVAS&gt</h1>
						<aside class="notes">
							Hello, my name is Marina & 
							I would like to tell you about canvas. 
						</aside>
					</section>
					<section>
						<img src="src/1.png" alt="">
						<aside class="notes">
								Canvas is a HTML element is used to draw graphics on a web page. 
								It is a bitmap with an "immediate mode" graphics 
								application programming interface (API) for drawing on it. 
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">&lt;CANVAS&gt can be used for:</h2>
						<ol>
							<li>Dynamic graphics</li>
							<li>Online and offline games</li>
							<li>Animations</li>
							<li>Interactive video and audio</li>
						</ol>
						<aside class="notes">
							Canvas can be used for:
							•	Dynamic graphics
							•	Online and offline games
							•	Animations
							•	Interactive video and audio
						</aside>
					</section>
					<section>
						<pre><code data-trim data-noescape>
							&lt;canvas id="example" width="150" height="150"&gt 
							&lt;/canvas&gt
						</code></pre>
						<aside class="notes">
							The canvas element is only a container for graphics. 
							In order to draw the graphics, you are supposed to use a script. 
							The canvas element has only two optional attributes, width and height. 
							The default values for heights are 300 px and 150 for heights.
						</aside>
					</section>
					<section style="min-width: 100%; padding: 0; margin: 0;">
					<pre><code data-trim data-noescape>
					function draw() {
					   const canvas = document.getElementById('canvas');
					   if (canvas.getContext) {
						let ctx = canvas.getContext('2d');
						ctx.beginPath();
						ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
						ctx.moveTo(110, 75); // Moves the pen 
						ctx.arc(75, 75, 35, 0, Math.PI, false);  // Mouth (clockwise)
						ctx.moveTo(65, 65); // Moves the pen
						ctx.arc(60, 65, 5, 0, Math.PI * 2, true);  // Left eye
						ctx.moveTo(95, 65); // Moves the pen
						ctx.arc(90, 65, 5, 0, Math.PI * 2, true);  // Right eye
						ctx.stroke();
					   }
					}
					</code></pre>
						<img src="src/2.jpg">
						<aside class="notes">
							Canvas has several strategies when it comes to drawing paths, 
							boxes, circles, text & adding images.
							On the slide you see the function, 
							and next is the result of its work.
							A bit of code:
							1. Function getContext('2d') needed to set context.
							2. Function beginPath() creates a new path. 
							3. Function arc (60, 65, 5, 0, Math.PI * 2, true) draws an arc which is centered at the point with coordinates (60, 65) position with radius 5 px starting at  startAngle = 0 and ending at endAngle = Math.PI*2 going in the given direction indicated by anticlockwise.
							4. Function moveTo(110, 75) moves the pen to the coordinates specified by 110 and 75.
							5. Function stroke() draws the shape by stroking its outline.
						</aside>
					</section>
					<section>
							<h2 style="color: yellow">And a little about the vaunted animation</h2>	
							<img src="src/html5-canvas-y-u-hate-me-so-much.jpg" alt="" width="450">
					</section>
					<section style="min-width: 100%; height: 100%; padding: 0; margin: 0;">
						<pre><code data-trim data-noescape id="mycode">
	function draw() {
	  const canvas = document.querySelector('canvas');
	  canvas.width = window.innerWidth;
	  canvas.height = window.innerHeight;
	  const c = canvas.getContext('2d');
	  const circlesCount = 800;
	  const maxRadius = 40;
	  const circleArray = [];
	  const colorArray = ['#046975','#2EA1D4','#3BCC2A','#FFDF59','#FF1D47'];
	
	  const debounce = (func) => {...}
	
	  const init = () => {...}
	
	  window.addEventListener('resize', debounce(() => {...})); 
	
	  const Circle = function(x, y, dx, dy, radius) {...}; 
	
	  const animate = () => {...};
	
	  init();
	  animate();}
						</code></pre>
						<a href="https://github.com/marry705/canvase_animation" target="_blank">THE CODE</a>
						<aside class="notes">
							And a little about the vaunted animation. 
							The whole question can be considered by clicking on the link, 
							but now we’ve stopped only on the function responsible for the animation.
						</aside>
					</section>
					<section>
						<pre><code data-trim data-noescape>
							const animate = () => {
							  requestAnimationFrame(animate);  
							  c.clearRect(0, 0, innerWidth, innerHeight); // clear shapes
							  for (let i = 0; i < circleArray.length; i++) {
								circleArray[i].update();
							  }
							}
						</code></pre>
						<a href="https://marry705.github.io/canvase_animation/" target="_blank">RESULT</a> 
						<aside class="notes">
							Elements are animated using a loop. Based on the example above, we animate the elements using a loop. 
							Every circle has its own «life» and moves. 
							When the border is reached it bounces back. 
							We slightly moving the image at every frame rendering iteration.
							1.	Method requestAnimationFrame(callback) tells the browser that you wish to perform an animation 
							and requests that the browser call a specified function to update an animation before the next repaint. 
							2.	clearRect() clears any shapes that have been drawn previously.
							3.	Update() – the circle class method, which internally changes the parameters of the circle (coordinates of its cent and radius) and then draws a new circle. 	
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">Basic animation steps</h2>
						<ol>
							<li>Clear the canvas</li>
							<li>Save the canvas state</li>
							<li>Draw animated shapes</li>
							<li>Restore the canvas state</li>
						</ol>
						<aside class="notes">
							These are the steps you need to take to draw a frame:
							1.	Clear the canvas								
							At first you need to clear any shapes that have been drawn previously. 
							2.	Save the canvas state
							If you're changing any setting (such as styles, transformations, etc.) which affect the canvas state and you want to make sure the original state is used each time a frame is drawn, you need to save that original state.
							3.	Draw animated shapes
							The step where you do the actual frame rendering.
							4.	Restore the canvas stat.
							If you've saved the state, restore it before drawing a new frame.		 
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">Browser Support for Canvas:</h2>
						<img src="src/3.jpg">
					</section>
				</section>
				<section>
					<section>
						<h1>When and why?</h1>
						<aside class="notes">
							Where and when it will be beneficial for the developer to apply canvas. 		 
						</aside>	
					</section>
					<section>
						<img src="src/4.jpg" alt="">
						<aside class="notes">
							It’s crucial to distinguish between something called immediate mode and retained mode. These are two different approaches to getting content to display in your browser.
							The Canvas API is an example of immediate mode: you, as the developer, need to work out the commands to draw objects, 
							create and maintain the model or scene of what the final output should look like, 
							and specify what needs to be updated. 
							The browser’s Graphics API simply communicates your drawing commands to the browser, 
							which then executes them. It’s mean that canvas hasn’t got a Document Object Model. 
							With canvas, you draw your pixels and the system forgets all about them, 
							thereby cutting down on the extra memory needed to maintain an internal model of your drawing.
							Everything is exactly the opposite with SVG (Scalable Vector Graphics), 
							where each drawn object is added to its internal model, which somewhat eases your developer life, 
							but with some cost in terms of performance.
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">What HTML5 Canvas Can Be Great For</h2>
						<aside class="notes">
							To summarize, 
							HTML5 Canvas is a resolution-dependent immediate drawing system 
							that doesn’t maintain its own model. The last feature is key to this technology’s drawing capabilities 
							being lightning-fast, which makes HTML5 Canvas great at performing the following tasks:
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">Ray Tracing</h2>
						<p>Ray tracing is a technique for creating 3D graphics.
							<br>
							Here’s a <a href="http://jupiter909.com/mark/jsrt-anim.html" target="_blank">raytracer application in action</a>.
						</p> 
						<aside class="notes">
							Ray tracing is a technique for creating 3D graphics. 
							If you’re curious, here’s a raytracer application in action by Mark Webster. 
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">Drawing a significant number of objects on a small surface</h2>
						<img src="src/5.jpg" alt="" width="450">
					</section>
					<section>
						<h2 style="color: yellow">Pixel replacement in videos</h2>
						<img src="src/6.png" alt="" width="450">
					</section>
					<section></section>
				</section>
				<section>
					<section>
						<h1>Сonclusion</h1>
					</section>
					<section>
						<h2 style="color: yellow">Advantages:</h2>
						<ol>
							<li>Canvas is really interactive</li>
							<li>With Canvas, you always have the option of saving images as .png or .jpg</li>
							<li>Any object that you draw on the canvas can be animated</li>
							<li>Very efficient in dealing with multiple elements</li>
						</ol>
						<aside class="notes">
							Advantages:
							1. Canvas is really interactive: 
							It responds to user interactions by listening for any touch events, 
							keywords and mouse
							2. With Canvas, you always have the option of saving images as .png or .jpg
							3. Any object that you draw on the canvas can be animated
							4. Very efficient in dealing with multiple elements
						</aside>
					</section>
					<section>
						<h2 style="color: yellow">Disadvantages:</h2>
						<ol>
							<li>Canvas is dependent on resolution</li>
							<li>Complex visualizations</li>
							<li>It has Poor text rendering capabilities</li>
							<li>It can be slow when drawing to large areas</li>
						</ol>
						<aside class="notes">
							Disadvantages:
							1.	Canvas is dependent on resolution;
							2.	Complex visualizations;
							3.	It has Poor text rendering capabilities;
							4.	It can be slow when drawing to large areas.	
						</aside>
					</section>
					<section>
						<h2>Instead of a thousand words</h2>
						<ol>
							<li><a href="http://1000.chromeexperiments.com/" target="_blank">BUBBLES</a></li>
							<li><a href="http://www.giantstepsmedias.com/" target="_blank">STARS</a></li>
						</ol>
						<aside class="notes">
							Instead of a thousand words. 
							Take a look at the canvas in action. 
							Follow the links provided.	
						</aside>
					</section>
					<section>
						<img src="src/thnk.jpg" alt="">
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
